
Te cuento, hay cosas que no se hacer y esto es lo máximo, la explicación es esta:
El código este llama a la función isPerfectSquare dos veces, una vez con el valor 5*x*x + 4 
y otra vez con el valor 5*x*x - 4. (son dos, los cabrones te lo ponen recursivo y doble para dar por culo...)

Si alguna de las llamadas a isPerfectSquare devuelve 1 (verdadero), entonces el número es un número de Fibonacci y la función isFibonacciNumber devuelve 1. 
De lo contrario, devuelve 0.

Empieza en la posición 700 que dice y pide el número de un usuario, osea que sirve para todos, no para un puto array.


.pos 0x700
main:
    # Obtener el número del usuario
    irmovl Stack, %rsp
    irmovl stdin, %rbx
    irmovl prompt, %rcx
    call readInt
    subl $4, %rsp
    rmmovl %eax, (%esp)

    # Verificar si es un número perfecto cuadrado
    call isPerfectSquare

    # Si es un número perfecto cuadrado, verificar si es un número de Fibonacci
    cmpl $0, %eax
    je isFibonacci

    # Si no es un número perfecto cuadrado, no es un número de Fibonacci
    irmovl notFib, %ecx
    call printStr
    irmovl newline, %ecx
    call printStr
    jmp exit

isFibonacci:
    # Verificar si es un número de Fibonacci
    call isFibonacciNumber
    cmpl $0, %eax
    je notFib

    # Si es un número de Fibonacci, imprimir mensaje
    irmovl fib, %ecx
    call printStr
    irmovl newline, %ecx
    call printStr
    jmp exit

notFib:
    # Si no es un número de Fibonacci, imprimir mensaje
    irmovl notFib, %ecx
    call printStr
    irmovl newline, %ecx
    call printStr

exit:
    # Salir del programa
    hlt

isPerfectSquare:
    # Verificar si el número es un cuadrado perfecto
    pushl %ebp
    rrmovl %esp, %ebp
    irmovl 4(%ebp), %ecx
    cmpl $0, %ecx
    jle isPerfectSquare_end

    xorl %edx, %edx
    movl $1, %eax
    movl $2, %ebx
    jmp isPerfectSquare_loop

isPerfectSquare_loop:
    cmpl %ecx, %eax
    jge isPerfectSquare_end
    addl %ebx, %eax
    addl $2, %ebx
    jmp isPerfectSquare_loop

isPerfectSquare_end:
    subl %ecx, %eax
    cmpl $0, %eax
    sete %al
    movzbl %al, %eax
    leave
    ret

isFibonacciNumber:
    # Verificar si el número es un número de Fibonacci
    pushl %ebp
    rrmovl %esp, %ebp
    irmovl 4(%ebp), %ecx
    irmovl $5, %edx
    irmovl %ecx, %eax
    imull %ecx, %eax
    imull %edx, %eax
    addl $4, %eax
    pushl %eax
    call isPerfectSquare
    addl $4, %esp
    cmpl $0, %eax
    je isFibonacciNumber_end
    irmovl $5, %edx
    irmovl %ecx, %eax
    imull %ecx, %eax
    imull %edx, %eax
    subl $4, %eax
    pushl %eax
    call isPerfectSquare
    addl $4, %esp

isFibonacciNumber_end:
    leave
    ret




